{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "type": "object",
  "properties": {
    "providerType": {
      "enum": [
        "FEATURE",
        "TILE"
      ]
    }
  },
  "required": [
    "providerType"
  ],
  "anyOf": [
    {
      "properties": {
        "providerSubType": {
          "enum": [
            "MBTILES",
            "WFS",
            "HTTP",
            "FEATURES",
            "SQL"
          ]
        }
      },
      "required": [
        "providerSubType"
      ]
    },
    {
      "required": [
        "featureProviderType"
      ],
      "properties": {
        "featureProviderType": {
          "enum": [
            "WFS",
            "SQL"
          ]
        }
      }
    }
  ],
  "allOf": [
    {
      "if": {
        "properties": {
          "providerType": {
            "const": "FEATURE"
          },
          "providerSubType": {
            "const": "WFS"
          }
        },
        "required": [
          "providerType",
          "providerSubType"
        ]
      },
      "then": {
        "$ref": "#/$defs/FeatureProviderWfsData"
      }
    },
    {
      "if": {
        "properties": {
          "providerType": {
            "const": "FEATURE"
          },
          "featureProviderType": {
            "const": "WFS"
          }
        },
        "required": [
          "providerType",
          "featureProviderType"
        ]
      },
      "then": {
        "$ref": "#/$defs/FeatureProviderWfsData"
      }
    },
    {
      "if": {
        "properties": {
          "providerType": {
            "const": "FEATURE"
          },
          "providerSubType": {
            "const": "SQL"
          }
        },
        "required": [
          "providerType",
          "providerSubType"
        ]
      },
      "then": {
        "$ref": "#/$defs/FeatureProviderSqlData"
      }
    },
    {
      "if": {
        "properties": {
          "providerType": {
            "const": "FEATURE"
          },
          "featureProviderType": {
            "const": "SQL"
          }
        },
        "required": [
          "providerType",
          "featureProviderType"
        ]
      },
      "then": {
        "$ref": "#/$defs/FeatureProviderSqlData"
      }
    },
    {
      "if": {
        "properties": {
          "providerType": {
            "const": "TILE"
          },
          "providerSubType": {
            "const": "FEATURES"
          }
        },
        "required": [
          "providerType",
          "providerSubType"
        ]
      },
      "then": {
        "$ref": "#/$defs/TileProviderFeaturesData"
      }
    },
    {
      "if": {
        "properties": {
          "providerType": {
            "const": "TILE"
          },
          "providerSubType": {
            "const": "MBTILES"
          }
        },
        "required": [
          "providerType",
          "providerSubType"
        ]
      },
      "then": {
        "$ref": "#/$defs/TileProviderMbtilesData"
      }
    },
    {
      "if": {
        "properties": {
          "providerType": {
            "const": "TILE"
          },
          "providerSubType": {
            "const": "HTTP"
          }
        },
        "required": [
          "providerType",
          "providerSubType"
        ]
      },
      "then": {
        "$ref": "#/$defs/TileProviderHttpData"
      }
    }
  ],
  "$defs": {
    "FeatureProviderWfsData": {
      "title": "FeatureProviderWfsData",
      "description": "# WFS  The specifics of the WFS feature provider.  ## Connection Info  The connection info object for OGC Web Feature Services has the following properties:  {@docTable:connectionInfo }  ### Example  {@docVar:example }  ## Path Syntax       The paths for WFS feature providers are generated by ldproxy when analyzing the WFS und     should not be changed.",
      "type": "object",
      "properties": {
        "id": {
          "title": "id",
          "description": "Unique identifier of the entity, has to match the filename. Allowed characters are     (A-Z, a-z), numbers (0-9), underscore and hyphen.",
          "type": "string"
        },
        "createdAt": {
          "title": "createdAt",
          "description": "",
          "type": "number"
        },
        "lastModified": {
          "title": "lastModified",
          "description": "",
          "type": "number"
        },
        "entityStorageVersion": {
          "title": "entityStorageVersion",
          "description": "",
          "type": "number"
        },
        "providerType": {
          "title": "providerType",
          "description": "Always `FEATURE`.",
          "type": "string"
        },
        "providerSubType": {
          "title": "providerSubType",
          "description": "`SQL` for SQL DBMS as data source, `WFS` for *OGC Web Feature Service* as data source.",
          "type": "string"
        },
        "featureProviderType": {
          "title": "featureProviderType",
          "description": "*Deprecated* See `providerSubType`.",
          "type": "string",
          "deprecated": true
        },
        "nativeCrs": {
          "title": "nativeCrs",
          "description": "Coordinate reference system of geometries in the dataset. The EPSG code of the     coordinate reference system is given as integer in `code`. `forceAxisOrder` may be set to     use a non-default axis order: `LON_LAT` uses longitude/east as first value and     latitude/north as second value, `LAT_LON` uses the reverse. `NONE` uses the default axis     order and is the default value. Example: The default coordinate reference system `CRS84`     would look like this: `code: 4326` and `forceAxisOrder: LON_LAT`.",
          "type": "object",
          "$ref": "#/$defs/EpsgCrs"
        },
        "nativeTimeZone": {
          "title": "nativeTimeZone",
          "description": "A timezone ID, such as `Europe/Berlin`. Is applied to temporal values without timezone     in the dataset.",
          "type": "string"
        },
        "defaultLanguage": {
          "title": "defaultLanguage",
          "description": "",
          "type": "string"
        },
        "typeValidation": {
          "title": "typeValidation",
          "description": "Optional type definition validation with regard to the data source (only for SQL).     `NONE` means no validation. With `LAX` the validation will fail and the provider will not     start, when issues are detected that would definitely lead to runtime errors. Issues that     might lead to runtime errors depending on the data will be logged as warning. With `STRICT`     the validation will fail for any detected issue. That means the provider will only start if     runtime errors with regard to the data source can be ruled out.",
          "type": "string"
        },
        "labelTemplate": {
          "title": "labelTemplate",
          "description": "",
          "type": "string"
        },
        "extensions": {
          "title": "extensions",
          "description": "",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "$ref": "#/$defs/ExtensionConfiguration"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "$ref": "#/$defs/ExtensionConfiguration"
              }
            }
          ]
        },
        "fragments": {
          "title": "fragments",
          "description": "Definition of reusable schema fragments that can be referenced using `schema` in     `types`. The entries are arbitrary [schema definitions](#schema-definitions).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/FeatureSchema"
          }
        },
        "codelists": {
          "title": "codelists",
          "description": "",
          "type": "object",
          "additionalProperties": {
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "auto": {
          "title": "auto",
          "description": "Option to generate missing definitions automatically from the data source.",
          "type": "boolean"
        },
        "autoPersist": {
          "title": "autoPersist",
          "description": "Option to persist definitions generated with `auto` to the configuration file. The     [Store](/application/40-store.md) must not be `READ_ONLY` for this to take effect.",
          "type": "boolean"
        },
        "autoTypes": {
          "title": "autoTypes",
          "description": "List of source types to include in derived `types` definitions when `auto: true`.     Currently only works for [SQL](sql.md).",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        },
        "connectionInfo": {
          "title": "connectionInfo",
          "description": "",
          "type": "object",
          "$ref": "#/$defs/ConnectionInfoWfsHttp"
        },
        "types": {
          "title": "types",
          "description": "Definition of feature types. The entries have to be [schema     definitions](#schema-definitions) with `type: OBJECT` and at least one property with `role:     ID`.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/FeatureSchema"
          }
        }
      },
      "additionalProperties": false
    },
    "FeatureProviderSqlData": {
      "title": "FeatureProviderSqlData",
      "description": "# SQL  The specifics of the SQL feature provider.  {@docTable:properties }  ## Connection Info  The connection info object for SQL databases has the following properties:  {@docTable:connectionInfo }  ### Pool  Settings for the connection pool.  {@docTable:pool }  ## Source Path Defaults       Defaults for the path expressions in `sourcePath`, also see [Source Path     Syntax](#path-syntax).  {@docTable:sourcePathDefaults }  ## Source Path Syntax       The fundamental elements of the path syntax are demonstrated in the example above. The     path to a property is formed by concatenating the relative paths (`sourcePath`) with \"/\". A     `sourcePath` has to be defined for the for object that represents the feature type and most     child objects.       On the first level the path is formed by a \"/\" followed by the table name for the feature     type. Every row in the table corresponds to a feature. Example: `/kita`       When defining a feature property on a deeper level using a column from the given table,     the path equals the column name, e.g. `name`. The full path will then be `/kita/name`.       A join is defined using the pattern `[id\u003dfk]tab`, where `id` is the primary key of the     table from the parent object, `fk` is the foreign key of the joining table and `tab` is the     name of the joining table. Example from above: `[oid\u003dkita_fk]plaetze`. When a junction table     should be used, two such joins are concatenated with \"/\", e.g. `[id\u003dfka]a_2_b/[fkb\u003did]tab_b`.       Rows for a table can be filtered by adding `{filter\u003dexpression}` after the table name,     where `expression` is a [CQL2 Text](https://docs.ogc.org/DRAFTS/21-065.html#cql2-text)     expression. For details see the module [Filter /     CQL](../../services/building-blocks/filter.md), which provides the implementation but does     not have to be enabled.       To select capacity information only when the value is not NULL and greater than zero in     the example above, the filter would look like this: `[oid\u003dkita_fk]plaetze{filter\u003danzahl IS     NOT NULL AND anzahl\u003e 0}`       A non-default sort key can be set by adding `{sortKey\u003dcolumnName}` after the table name.  ## Query Generation       Options for query generation.  {@docTable:queryGeneration }",
      "type": "object",
      "properties": {
        "id": {
          "title": "id",
          "description": "Unique identifier of the entity, has to match the filename. Allowed characters are     (A-Z, a-z), numbers (0-9), underscore and hyphen.",
          "type": "string"
        },
        "createdAt": {
          "title": "createdAt",
          "description": "",
          "type": "number"
        },
        "lastModified": {
          "title": "lastModified",
          "description": "",
          "type": "number"
        },
        "entityStorageVersion": {
          "title": "entityStorageVersion",
          "description": "",
          "type": "number"
        },
        "providerType": {
          "title": "providerType",
          "description": "Always `FEATURE`.",
          "type": "string"
        },
        "providerSubType": {
          "title": "providerSubType",
          "description": "`SQL` for SQL DBMS as data source, `WFS` for *OGC Web Feature Service* as data source.",
          "type": "string"
        },
        "featureProviderType": {
          "title": "featureProviderType",
          "description": "*Deprecated* See `providerSubType`.",
          "type": "string",
          "deprecated": true
        },
        "nativeCrs": {
          "title": "nativeCrs",
          "description": "Coordinate reference system of geometries in the dataset. The EPSG code of the     coordinate reference system is given as integer in `code`. `forceAxisOrder` may be set to     use a non-default axis order: `LON_LAT` uses longitude/east as first value and     latitude/north as second value, `LAT_LON` uses the reverse. `NONE` uses the default axis     order and is the default value. Example: The default coordinate reference system `CRS84`     would look like this: `code: 4326` and `forceAxisOrder: LON_LAT`.",
          "type": "object",
          "$ref": "#/$defs/EpsgCrs"
        },
        "nativeTimeZone": {
          "title": "nativeTimeZone",
          "description": "A timezone ID, such as `Europe/Berlin`. Is applied to temporal values without timezone     in the dataset.",
          "type": "string"
        },
        "defaultLanguage": {
          "title": "defaultLanguage",
          "description": "",
          "type": "string"
        },
        "typeValidation": {
          "title": "typeValidation",
          "description": "Optional type definition validation with regard to the data source (only for SQL).     `NONE` means no validation. With `LAX` the validation will fail and the provider will not     start, when issues are detected that would definitely lead to runtime errors. Issues that     might lead to runtime errors depending on the data will be logged as warning. With `STRICT`     the validation will fail for any detected issue. That means the provider will only start if     runtime errors with regard to the data source can be ruled out.",
          "type": "string"
        },
        "labelTemplate": {
          "title": "labelTemplate",
          "description": "",
          "type": "string"
        },
        "extensions": {
          "title": "extensions",
          "description": "",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "$ref": "#/$defs/ExtensionConfiguration"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "$ref": "#/$defs/ExtensionConfiguration"
              }
            }
          ]
        },
        "codelists": {
          "title": "codelists",
          "description": "",
          "type": "object",
          "additionalProperties": {
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "auto": {
          "title": "auto",
          "description": "Option to generate missing definitions automatically from the data source.",
          "type": "boolean"
        },
        "autoPersist": {
          "title": "autoPersist",
          "description": "Option to persist definitions generated with `auto` to the configuration file. The     [Store](/application/40-store.md) must not be `READ_ONLY` for this to take effect.",
          "type": "boolean"
        },
        "autoTypes": {
          "title": "autoTypes",
          "description": "List of source types to include in derived `types` definitions when `auto: true`.     Currently only works for [SQL](sql.md).",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        },
        "connectionInfo": {
          "title": "connectionInfo",
          "description": "See [Connection Info](#connection-info).",
          "type": "object",
          "$ref": "#/$defs/ConnectionInfoSql"
        },
        "sourcePathDefaults": {
          "title": "sourcePathDefaults",
          "description": "Defaults for the path expressions in `sourcePath`, for details see [Source Path     Defaults](#source-path-defaults) below.",
          "type": "object",
          "$ref": "#/$defs/SqlPathDefaults"
        },
        "queryGeneration": {
          "title": "queryGeneration",
          "description": "Options for query generation, for details see [Query Generation](#query-generation)     below.",
          "type": "object",
          "$ref": "#/$defs/QueryGeneratorSettings"
        },
        "types": {
          "title": "types",
          "description": "Definition of feature types. The entries have to be [schema     definitions](#schema-definitions) with `type: OBJECT` and at least one property with `role:     ID`.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/FeatureSchema"
          }
        },
        "fragments": {
          "title": "fragments",
          "description": "Definition of reusable schema fragments that can be referenced using `schema` in     `types`. The entries are arbitrary [schema definitions](#schema-definitions).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/FeatureSchema"
          }
        }
      },
      "additionalProperties": false
    },
    "TileProviderFeaturesData": {
      "title": "TileProviderFeaturesData",
      "description": "# Features  In this tile provider, the tiles in Mapbox Vector Tiles format are derived from a     [Feature Provider](../feature/README.md).       ## Configuration       {@docTable:properties }       {@docVar:tilesetDefaults }       {@docTable:tilesetDefaults }       {@docVar:tileset }       {@docTable:tileset }       {@docVar:cache }       {@docTable:cache }       {@docVar:seeding }       {@docTable:seeding }       ## Example       {@docVar:examples }",
      "type": "object",
      "properties": {
        "id": {
          "title": "id",
          "description": "Unique identifier of the entity, has to match the filename. Allowed characters are     (A-Z, a-z), numbers (0-9), underscore and hyphen.",
          "type": "string"
        },
        "createdAt": {
          "title": "createdAt",
          "description": "",
          "type": "number"
        },
        "lastModified": {
          "title": "lastModified",
          "description": "",
          "type": "number"
        },
        "entityStorageVersion": {
          "title": "entityStorageVersion",
          "description": "",
          "type": "number"
        },
        "providerType": {
          "title": "providerType",
          "description": "Always `TILE`.",
          "type": "string"
        },
        "providerSubType": {
          "title": "providerSubType",
          "description": "Always `FEATURES`.",
          "type": "string"
        },
        "auto": {
          "title": "auto",
          "description": "Option to generate missing definitions automatically from the data source.",
          "type": "boolean"
        },
        "autoPersist": {
          "title": "autoPersist",
          "description": "Option to persist definitions generated with `auto` to the configuration file. The     [Store](/application/40-store.md) must not be `READ_ONLY` for this to take effect.",
          "type": "boolean"
        },
        "tilesetDefaults": {
          "title": "tilesetDefaults",
          "description": "Defaults for all `tilesets`, see [Tileset Defaults](#tileset-defaults).",
          "type": "object",
          "$ref": "#/$defs/TilesetFeaturesDefaults"
        },
        "tilesets": {
          "title": "tilesets",
          "description": "Definition of tilesets, see [Tileset](#tileset).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/TilesetFeatures"
          }
        },
        "caches": {
          "title": "caches",
          "description": "List of cache definitions, see [Cache](#cache).",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "$ref": "#/$defs/Cache"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "$ref": "#/$defs/Cache"
              }
            }
          ]
        },
        "seeding": {
          "title": "seeding",
          "description": "Controls how and when tiles are precomputed, see [Seeding](#seeding).",
          "type": "object",
          "$ref": "#/$defs/SeedingOptions"
        }
      },
      "additionalProperties": false
    },
    "TileProviderMbtilesData": {
      "title": "TileProviderMbtilesData",
      "description": "# MBTiles  With this tile provider, the tiles are provided via an [MBTiles     file](https://github.com/mapbox/mbtiles-spec). The tile format and all other properties of     the tileset are derived from the contents of the MBTiles file. Only the `WebMercatorQuad`     tiling scheme is supported.       ## Configuration       {@docTable:properties }       ### Tileset       {@docTable:tileset }       ## Example       {@docVar:examples }",
      "type": "object",
      "properties": {
        "id": {
          "title": "id",
          "description": "Unique identifier of the entity, has to match the filename. Allowed characters are     (A-Z, a-z), numbers (0-9), underscore and hyphen.",
          "type": "string"
        },
        "createdAt": {
          "title": "createdAt",
          "description": "",
          "type": "number"
        },
        "lastModified": {
          "title": "lastModified",
          "description": "",
          "type": "number"
        },
        "entityStorageVersion": {
          "title": "entityStorageVersion",
          "description": "",
          "type": "number"
        },
        "providerType": {
          "title": "providerType",
          "description": "Always `TILE`.",
          "type": "string"
        },
        "providerSubType": {
          "title": "providerSubType",
          "description": "Always `MBTILES`.",
          "type": "string"
        },
        "tilesetDefaults": {
          "title": "tilesetDefaults",
          "description": "Defaults for all `tilesets`.",
          "type": "object",
          "$ref": "#/$defs/TilesetMbTilesDefaults"
        },
        "tilesets": {
          "title": "tilesets",
          "description": "Definition of tilesets.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/TilesetMbTiles"
          }
        }
      },
      "additionalProperties": false
    },
    "TileProviderHttpData": {
      "title": "TileProviderHttpData",
      "description": "# HTTP  With this tile provider, the tiles are obtained via HTTP, e.g. from a     [TileServer-GL](https://github.com/maptiler/tileserver-gl) instance.       ## Configuration       {@docTable:properties }       {@docVar:tilesetDefaults }       {@docTable:tilesetDefaults }       {@docVar:tileset }       {@docTable:tileset }       ## Example       {@docVar:examples }",
      "type": "object",
      "properties": {
        "id": {
          "title": "id",
          "description": "Unique identifier of the entity, has to match the filename. Allowed characters are     (A-Z, a-z), numbers (0-9), underscore and hyphen.",
          "type": "string"
        },
        "createdAt": {
          "title": "createdAt",
          "description": "",
          "type": "number"
        },
        "lastModified": {
          "title": "lastModified",
          "description": "",
          "type": "number"
        },
        "entityStorageVersion": {
          "title": "entityStorageVersion",
          "description": "",
          "type": "number"
        },
        "providerType": {
          "title": "providerType",
          "description": "Always `TILE`.",
          "type": "string"
        },
        "providerSubType": {
          "title": "providerSubType",
          "description": "Always `HTTP`.",
          "type": "string"
        },
        "tilesetDefaults": {
          "title": "tilesetDefaults",
          "description": "Defaults for all `tilesets`, see [Tileset Defaults](#tileset-defaults).",
          "type": "object",
          "$ref": "#/$defs/TilesetHttpDefaults"
        },
        "tilesets": {
          "title": "tilesets",
          "description": "Definition of tilesets, see [Tileset](#tileset).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/TilesetHttp"
          }
        }
      },
      "additionalProperties": false
    },
    "EpsgCrs": {
      "title": "EpsgCrs",
      "description": "",
      "type": "object",
      "properties": {
        "code": {
          "title": "code",
          "description": "",
          "type": "number"
        },
        "verticalCode": {
          "title": "verticalCode",
          "description": "",
          "type": "number"
        },
        "forceLongitudeFirst": {
          "title": "forceLongitudeFirst",
          "description": "",
          "type": "boolean",
          "deprecated": true
        },
        "forceAxisOrder": {
          "title": "forceAxisOrder",
          "description": "",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "FeatureChangesPgConfiguration": {
      "title": "FeatureChangesPgConfiguration",
      "description": "```yaml  - type: FEATURE_CHANGES_PG   enabled: true   listenForTypes: # optional, default is to listen for all types   - governmentalservice   pollingInterval: 30s # optional, default is 60s  ```",
      "type": "object",
      "properties": {
        "enabled": {
          "title": "enabled",
          "description": "Enable the extension?",
          "type": "boolean"
        },
        "listenForTypes": {
          "title": "listenForTypes",
          "description": "List of types that should be observed. An empty list means all types.",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        },
        "pollingInterval": {
          "title": "pollingInterval",
          "description": "Since the JDBC driver for PostgreSQL does not support real reactivity, it has to be     polled for changes with the given interval.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "Preference": {
      "title": "Preference",
      "description": "",
      "type": "object",
      "properties": {
        "label": {
          "title": "label",
          "description": "",
          "type": "string"
        },
        "costColumn": {
          "title": "costColumn",
          "description": "",
          "type": "string"
        },
        "reverseCostColumn": {
          "title": "reverseCostColumn",
          "description": "",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "RoutesConfiguration": {
      "title": "RoutesConfiguration",
      "description": "```yaml  extensions:   - type: ROUTES     enabled: true     warmup: true     fromToQuery:       driving: \u0027SELECT id as oid, ST_Distance(${point},the_geom) AS distance FROM v_ways_vertices_pgr WHERE connected and ST_DWithin(${point},the_geom, 0.25) ORDER BY distance ASC LIMIT 1\u0027     edgesQuery:       driving: \u0027SELECT gid as id, source, target, x1, y1, x2, y2, ${cost_column} AS cost, ${reverse_cost_column} AS reverse_cost, maxheight, maxweight FROM v_ways WHERE tag_id NOT IN (113, 114, 115, 116, 117, 118, 119, 120, 122, 201, 202, 203, 204, 301, 302, 303, 304, 305)\u0027     routeQuery: \u0027SELECT * from pgr_aStar(${edgesQuery}, ${from_vid}, ${to_vid}, ${height}, ${weight}, \u0027\u0027SELECT gid FROM v_ways WHERE ST_Intersects(the_geom, ${obstacles})\u0027\u0027, false, 5, (1+8+16))\u0027     nativeCrs:       code: 4326       forceAxisOrder: LON_LAT     preferences:       fastest:         label: Fastest         costColumn: cost_s         reverseCostColumn: reverse_cost_s       shortest:         label: Shortest         costColumn: cost         reverseCostColumn: reverse_cost     modes:       driving: Driving types:   route:     type: OBJECT     sourcePath: /_route_     properties:       id:         sourcePath: id         type: INTEGER         role: ID       edge:         sourcePath: edge         type: INTEGER       node:         sourcePath: node         type: INTEGER       cost:         sourcePath: cost         type: FLOAT       agg_cost:         sourcePath: agg_cost         type: FLOAT       data:         type: OBJECT         sourcePath: \u0027[edge\u003dgid]v_ways{sortKey\u003dgid}\u0027         properties:           geometry:             sourcePath: the_geom             type: GEOMETRY             geometryType: LINE_STRING             role: PRIMARY_GEOMETRY             forcePolygonCCW: false           source:             sourcePath: source             type: INTEGER           target:             sourcePath: target             type: INTEGER           type:             sourcePath: tag_id             type: STRING             transformations:               codelist: wayTag           #osm_id:           #  sourcePath: osm_id           #  type: INTEGER           length_m:             sourcePath: length_m             type: FLOAT           duration_forward_s:             sourcePath: cost_s             type: FLOAT           duration_backward_s:             sourcePath: reverse_cost_s             type: FLOAT           roadName:             sourcePath: name             type: STRING           oneway:             sourcePath: oneway             type: STRING           maxspeed_forward:             sourcePath: maxspeed_forward             type: FLOAT           maxspeed_backward:             sourcePath: maxspeed_backward             type: FLOAT           maxHeight_m:             sourcePath: maxheight             type: FLOAT           maxWeight_t:             sourcePath: maxweight             type: FLOAT  ```",
      "type": "object",
      "properties": {
        "enabled": {
          "title": "enabled",
          "description": "Enable the extension?",
          "type": "boolean"
        },
        "fromToQuery": {
          "title": "fromToQuery",
          "description": "*Required* The SQL query to determine the start and end vertex of the route. `${point}`     will be replaced with the WKT POINT geometry of the waypoint to use as start/end.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "edgesQuery": {
          "title": "edgesQuery",
          "description": "*Required* The SQL query to determine the edges / route segments of the route.     `${cost_column}` and `${reverse_cost_column}` will be replaced with the column names to use     for optimizing the route. `${cost_column}` is the value in the direction of the edge,     `${reverse_cost_column}` in the opposite direction.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "routeQuery": {
          "title": "routeQuery",
          "description": "*Required* The SQL query to compute the route. Use `${edgesQuery}` as placeholder for     the `edgesQuery`, `${from_vid}` and `${to_vid}` as placeholders for the start/end vertex.     If supported, use `${height}`, `${weight}`, and `${obstacles}` as placeholders for the     height, weight and area constraints. `${flag_mask}`, if provided, is replaced by the sum of     all additional flags set for the routing request.",
          "type": "string"
        },
        "flags": {
          "title": "flags",
          "description": "Additional flags that can be set to consider during the computation of the route. The     integer value of a flag must be a unique bit value.",
          "type": "object",
          "additionalProperties": {
            "type": "number"
          }
        },
        "nativeCrs": {
          "title": "nativeCrs",
          "description": "Coordinate reference system of geometries in the routing dataset. The EPSG code of the     coordinate reference system is given as integer in `code`. `forceAxisOrder` may be set to     use a non-default axis order: `LON_LAT` uses longitude/east as first value and     latitude/north as second value, `LAT_LON` uses the reverse. `NONE` uses the default axis     order and is the default value. Example: The default coordinate reference system `CRS84`     would look like this: `code: 4326` and `forceAxisOrder: LON_LAT`.",
          "type": "object",
          "$ref": "#/$defs/EpsgCrs"
        },
        "preferences": {
          "title": "preferences",
          "description": "*Required* Lists the available options for optimizing the route. The key is the     preference id, the value an object of key-value pairs with the following required keys:     \"label\", \"costColumn\" (name of the column in the table of network segment to minimize, if     the segment is traveled in positive direction), \"reverseCostColumn\" (same, but for     travelling in negative direction).",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/Preference"
          }
        },
        "modes": {
          "title": "modes",
          "description": "Lists the available modes of transportation, the key is the mode id, the value a     descriptive label.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "weightDefault": {
          "title": "weightDefault",
          "description": "Sets a default value for the weight of a vehicle in tons. `0` means no weight.",
          "type": "string"
        },
        "heightDefault": {
          "title": "heightDefault",
          "description": "Sets a default value for the height of a vehicle in meters. `0` means no height.",
          "type": "string"
        },
        "obstaclesDefault": {
          "title": "obstaclesDefault",
          "description": "Sets a default value for an area to avoid.",
          "type": "string"
        },
        "warmup": {
          "title": "warmup",
          "description": "Enables a route calculation with the default values at provider startup. This can be     useful, if the routing algorithm caches certain information.",
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "JsonSchemaConfiguration": {
      "title": "JsonSchemaConfiguration",
      "description": "```yaml  - type: JSON_SCHEMA   enabled: true   objectTypeRefs:     \u0027#/$defs/Link\u0027: Link  ```",
      "type": "object",
      "properties": {
        "enabled": {
          "title": "enabled",
          "description": "Enable the extension?",
          "type": "boolean"
        },
        "objectTypeRefs": {
          "title": "objectTypeRefs",
          "description": "Allows to map JSON schema definitions to an `objectType`, e.g. `\u0027#/$defs/Link\u0027: Link`.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "geometryTypeRefs": {
          "title": "geometryTypeRefs",
          "description": "Allows to map JSON schema definitions to a `geometryType`, e.g.     `https://geojson.org/schema/LineString.json\u0027: LINE_STRING`.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "relationRefs": {
          "title": "relationRefs",
          "description": "Allows to map JSON schema definitions to a `refType`, e.g. `\u0027#/$defs/Address\u0027:     address`.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "compositionIndexes": {
          "title": "compositionIndexes",
          "description": "Allows to choose a specific variant for oneOf/anyOf/allOf.",
          "type": "object",
          "additionalProperties": {
            "type": "number"
          }
        }
      },
      "additionalProperties": false
    },
    "ExtensionConfiguration": {
      "type": "object",
      "properties": {
        "type": {
          "enum": [
            "FEATURE_CHANGES_PG",
            "ROUTES",
            "JSON_SCHEMA"
          ]
        }
      },
      "required": [
        "type"
      ],
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "FEATURE_CHANGES_PG"
              }
            },
            "required": [
              "type"
            ]
          },
          "then": {
            "$ref": "#/$defs/FeatureChangesPgConfiguration"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "ROUTES"
              }
            },
            "required": [
              "type"
            ]
          },
          "then": {
            "$ref": "#/$defs/RoutesConfiguration"
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "JSON_SCHEMA"
              }
            },
            "required": [
              "type"
            ]
          },
          "then": {
            "$ref": "#/$defs/JsonSchemaConfiguration"
          }
        }
      ]
    },
    "PropertyTransformation": {
      "title": "PropertyTransformation",
      "description": "# Transformations  Transformations are supported in multiple parts of the configuration. Transformations do     not affect data sources, they are applied on-the-fly as part of the encoding. Filter     expressions do not take transformations into account, they have to be based on the source     values.  {@docTable:properties }  ## Examples for `stringFormat`       \u003cspan v-pre\u003e`https://example.com/id/kinder/kita/{{value}}`\u003c/span\u003e inserts the value into     the URI template.       \u003cspan v-pre\u003e`{{value | replace:\u0027\\\\s*[0-9].*$\u0027:\u0027\u0027}}`\u003c/span\u003e removes all white space and     numbers at the end (e.g. to remove a street number)       \u003cspan v-pre\u003e`{{value | replace:\u0027^[^0-9]*\u0027:\u0027\u0027}}`\u003c/span\u003e removes everything before the first     digit       \u003cspan v-pre\u003e`{{value | toUpper}}`\u003c/span\u003e transforms the value to upper case       \u003cspan v-pre\u003e`{{value | toLower}}`\u003c/span\u003e transforms the value to lower case       \u003cspan v-pre\u003e`{{value | urlEncode}}`\u003c/span\u003e encodes special characters in the text for     usage as aprt of an URI       \u003cspan v-pre\u003e`[{{value}}](https://de.wikipedia.org/wiki/{{value | replace:\u0027 \u0027:\u0027_\u0027 |     urlencode}})`\u003c/span\u003e transforms a value into a markdown link to a Wikipedia entry",
      "type": "object",
      "properties": {
        "rename": {
          "title": "rename",
          "description": "Rename a property.",
          "type": "string"
        },
        "remove": {
          "title": "remove",
          "description": "`IN_COLLECTION` (until version 3.0: `OVERVIEW`) skips the property only for the     *Features* resource, `ALWAYS` always skips it, `NEVER` never skips it.",
          "type": "string"
        },
        "flatten": {
          "title": "flatten",
          "description": "Flattens object or array properties using the given separator. For arrays the property     name is formed by the original property name followed by pairs of separator and array     position. For objects the property name is formed by concatenating the original property     separated by the given separator. Can only be applied on the feature level in the provider     or using the wildcard property name `*` otherwise.",
          "type": "string"
        },
        "reduceStringFormat": {
          "title": "reduceStringFormat",
          "description": "Reduces an object to a string using the same syntax as `stringFormat` but with     additional replacements for objects property names.",
          "type": "string"
        },
        "stringFormat": {
          "title": "stringFormat",
          "description": "Format a value, where `{{value}}` is replaced with the actual value and     `{{serviceUrl}}` is replaced with the API landing page URI. Additonal operations can be     applied to `{{value}}` by chaining them with `|`, see the examples below.",
          "type": "string"
        },
        "dateFormat": {
          "title": "dateFormat",
          "description": "Format date(-time) values with the given     [pattern](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/format/DateTimeFormatter.html#patterns),     e.g. `dd.MM.yyyy` for German notation.",
          "type": "string"
        },
        "codelist": {
          "title": "codelist",
          "description": "Maps the value according to the given [codelist](../../auxiliaries/codelists.md). If     the value is not found in the codelist or the codelist does not exist, the original value     is passed through. Falls der Wert nicht in der Codelist enthalten ist oder die Codelist     nicht gefunden wird, bleibt der Wert unverändert. Not applicable for properties containing     objects.",
          "type": "string"
        },
        "nullify": {
          "title": "nullify",
          "description": "Maps all values matching the list of regular expressions to `null`. Not applicable for     properties containing objects.",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        },
        "null": {
          "title": "null",
          "description": "*Deprecated* See `nullify`.",
          "type": "string",
          "deprecated": true
        },
        "asLink": {
          "title": "asLink",
          "description": "TODO",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "SchemaConstraints": {
      "title": "SchemaConstraints",
      "description": "# Constraints  Currently only available in [German](../../de/providers/details/constraints.md).",
      "type": "object",
      "properties": {
        "codelist": {
          "title": "codelist",
          "description": "TODO",
          "type": "string"
        },
        "enum": {
          "title": "enum",
          "description": "TODO",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        },
        "regex": {
          "title": "regex",
          "description": "TODO",
          "type": "string"
        },
        "required": {
          "title": "required",
          "description": "TODO",
          "type": "boolean"
        },
        "min": {
          "title": "min",
          "description": "TODO",
          "type": "number"
        },
        "max": {
          "title": "max",
          "description": "TODO",
          "type": "number"
        },
        "minOccurrence": {
          "title": "minOccurrence",
          "description": "TODO",
          "type": "number"
        },
        "maxOccurrence": {
          "title": "maxOccurrence",
          "description": "TODO",
          "type": "number"
        },
        "composite": {
          "title": "composite",
          "description": "Flag to indicate that all geometry components are connected. Only relevant for     properties with MultiLineString and MultiPolygon geometries.",
          "type": "boolean"
        },
        "closed": {
          "title": "closed",
          "description": "Flag to indicate that all geometry values are closed. Only relevant for geometry     properties.",
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "PartialObjectSchema": {
      "title": "PartialObjectSchema",
      "description": "",
      "type": "object",
      "properties": {
        "sourcePath": {
          "title": "sourcePath",
          "description": "",
          "type": "string"
        },
        "schema": {
          "title": "schema",
          "description": "",
          "type": "string"
        },
        "properties": {
          "title": "properties",
          "description": "Only for `OBJECT` and `OBJECT_ARRAY`. Object with the property names as keys and schema     objects as values.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/FeatureSchema"
          }
        }
      },
      "additionalProperties": false
    },
    "FeatureSchema": {
      "title": "FeatureSchema",
      "description": "",
      "type": "object",
      "properties": {
        "refType": {
          "title": "refType",
          "description": "",
          "type": "string"
        },
        "refUriTemplate": {
          "title": "refUriTemplate",
          "description": "",
          "type": "string"
        },
        "sourcePath": {
          "title": "sourcePath",
          "description": "The relative path for this schema object. The syntax depends on the provider types, see     [SQL](sql.md#path-syntax) or [WFS](wfs.md#path-syntax).",
          "type": "string"
        },
        "path": {
          "title": "path",
          "description": "*Deprecated* See `sourcePath`.",
          "type": "string",
          "deprecated": true
        },
        "sourcePaths": {
          "title": "sourcePaths",
          "description": "The relative paths for this schema object. The syntax depends on the provider types,     see [SQL](sql.md#path-syntax) or [WFS](wfs.md#path-syntax).",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        },
        "type": {
          "title": "type",
          "description": "Data type of the schema object. Default is `OBJECT` when `properties` is set, otherwise     it is `STRING`. Possible values:        - `FLOAT`, `INTEGER`, `STRING`, `BOOLEAN`, `DATETIME`, `DATE` for simple values. - `GEOMETRY` for geometries. - `OBJECT` for objects. - `OBJECT_ARRAY` a list of objects. - `VALUE_ARRAY` a list of simple values.",
          "type": "string"
        },
        "role": {
          "title": "role",
          "description": "`ID` has to be set for the property that should be used as the unique feature id. As a     rule that should be the first property ion the `properties` object. Property names cannot     contain spaces (\" \") or slashes (\"/\"). Set `TYPE` for a property that specifies the type     name of the object.",
          "type": "string"
        },
        "valueType": {
          "title": "valueType",
          "description": "Only needed when `type` is `VALUE_ARRAY`. Possible values: `FLOAT`, `INTEGER`,     `STRING`, `BOOLEAN`, `DATETIME`, `DATE`",
          "type": "string"
        },
        "geometryType": {
          "title": "geometryType",
          "description": "The specific geometry type for properties with `type: GEOMETRY`. Possible values are     simple feature geometry types: `POINT`, `MULTI_POINT`, `LINE_STRING`, `MULTI_LINE_STRING`,     `POLYGON`, `MULTI_POLYGON`, `GEOMETRY_COLLECTION` and `ANY`",
          "type": "string"
        },
        "objectType": {
          "title": "objectType",
          "description": "Optional name for an object type, used for example in JSON Schema. For properties that     should be mapped as links according to *RFC 8288*, use `Link`.",
          "type": "string"
        },
        "label": {
          "title": "label",
          "description": "Label for the schema object, used for example in HTML representations.",
          "type": "string"
        },
        "description": {
          "title": "description",
          "description": "Description for the schema object, used for example in HTML representations or JSON     Schema.",
          "type": "string"
        },
        "unit": {
          "title": "unit",
          "description": "The unit of measurement of the value, only relevant for numeric properties.",
          "type": "string"
        },
        "constantValue": {
          "title": "constantValue",
          "description": "Might be used instead of `sourcePath` to define a property with a constant value.",
          "type": "string"
        },
        "scope": {
          "title": "scope",
          "description": "Optional scope for properties that should only be used when either reading (`QUERIES`)     or writing (`MUTATIONS`) features.",
          "type": "string"
        },
        "schema": {
          "title": "schema",
          "description": "Reference to an external schema definition. The default resolver will resolve     references to entries in `fragments` e.g. `#/fragments/example`. For additional resolvers     see [Extensions](extensions).",
          "type": "string"
        },
        "ignore": {
          "title": "ignore",
          "description": "Option to completely ignore this schema object. Main purpose is to ignore parts of     schemas referenced with `schema`.",
          "type": "boolean"
        },
        "transformations": {
          "title": "transformations",
          "description": "Optional transformations for the property, see     [transformations](../details/transformations.md).",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "$ref": "#/$defs/PropertyTransformation"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "$ref": "#/$defs/PropertyTransformation"
              }
            }
          ]
        },
        "constraints": {
          "title": "constraints",
          "description": "Optional description of schema constraints, especially for JSON schema generation. See     [Constraints](../details/constraints.md).",
          "type": "object",
          "$ref": "#/$defs/SchemaConstraints"
        },
        "forcePolygonCCW": {
          "title": "forcePolygonCCW",
          "description": "Option to disable enforcement of counter-clockwise orientation for exterior rings and a     clockwise orientation for interior rings (only for SQL).",
          "type": "boolean"
        },
        "isQueryable": {
          "title": "isQueryable",
          "description": "Properties that are not of type OBJECT or OBJECT_ARRAY are by default eligible as     queryables. This setting can be used to declare a property as ineligible, for example, if     the property is not optimized for use in queries. If an eligible property can actually be     queried is decided by the provider implementation, that might not be feasible due to     technical reasons.",
          "type": "boolean"
        },
        "isSortable": {
          "title": "isSortable",
          "description": "Only the direct properties of a feature type that are of type STRING, FLOAT, INTEGER,     DATE, or TIMESTAMP are eligible as sortables. This setting can be used to declare a     property as ineligible, for example, if the property is not optimized for use in queries.     If an eligible property can actually be used as sortable is decided by the provider     implementation, that might not be feasible due to technical reasons.",
          "type": "boolean"
        },
        "properties": {
          "title": "properties",
          "description": "Only for `OBJECT` and `OBJECT_ARRAY`. Object with the property names as keys and schema     objects as values.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/FeatureSchema"
          }
        },
        "merge": {
          "title": "merge",
          "description": "If only some of the `properties` are defined in an external `schema`, or if some of the     `properties` should be mapped to a different table, this provides a convenient way to     define these properties alongside the regular properties. The option takes a list of schema     objects, but only `sourcePath`, `schema` and `properties` are considered. For details see     [Mapping Operations](#merge).",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "$ref": "#/$defs/PartialObjectSchema"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "$ref": "#/$defs/PartialObjectSchema"
              }
            }
          ]
        },
        "allOf": {
          "title": "allOf",
          "description": "*Deprecated* See `merge`.",
          "deprecated": true,
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "$ref": "#/$defs/PartialObjectSchema"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "$ref": "#/$defs/PartialObjectSchema"
              }
            }
          ]
        },
        "coalesce": {
          "title": "coalesce",
          "description": "If the value for a property may come from more than one `sourcePath`, this allows to     choose the first non-null value. This takes a list of value schemas, for details see     [Mapping Operations](#coalesce).",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "$ref": "#/$defs/FeatureSchema"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "$ref": "#/$defs/FeatureSchema"
              }
            }
          ]
        },
        "concat": {
          "title": "concat",
          "description": "If the values for an array property may come from more than one `sourcePath`, this     allows to concatenate all available values. This takes a list of value or value array     schemas, for details see [Mapping Operations](#concat).",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "$ref": "#/$defs/FeatureSchema"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "$ref": "#/$defs/FeatureSchema"
              }
            }
          ]
        },
        "additionalInfo": {
          "title": "additionalInfo",
          "description": "",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "ConnectionInfoWfsHttp": {
      "title": "ConnectionInfoWfsHttp",
      "description": "",
      "type": "object",
      "properties": {
        "connectionUri": {
          "title": "connectionUri",
          "description": "",
          "type": "string"
        },
        "version": {
          "title": "version",
          "description": "The WFS version to use.",
          "type": "string"
        },
        "gmlVersion": {
          "title": "gmlVersion",
          "description": "The GML version to use.",
          "type": "string"
        },
        "namespaces": {
          "title": "namespaces",
          "description": "A map of namespace prefixes and URIs used in the mapping paths.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "connectorType": {
          "title": "connectorType",
          "description": "Always `HTTP`.",
          "type": "string"
        },
        "uri": {
          "title": "uri",
          "description": "The URI of the GetCapabilities operation for the WFS.",
          "type": "string"
        },
        "method": {
          "title": "method",
          "description": "The HTTP method to use, `GET` or `POST`.",
          "type": "string"
        },
        "user": {
          "title": "user",
          "description": "The user name for HTTP Basic Auth.",
          "type": "string"
        },
        "password": {
          "title": "password",
          "description": "The base64 encoded password for HTTP Basic Auth.",
          "type": "string"
        },
        "otherUrls": {
          "title": "otherUrls",
          "description": "",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        }
      },
      "additionalProperties": false
    },
    "PoolSettings": {
      "title": "PoolSettings",
      "description": "",
      "type": "object",
      "properties": {
        "maxConnections": {
          "title": "maxConnections",
          "description": "Maximum number of connections to the database. The default value is computed     depending on the number of processor cores and the maximum number of joins per feature     type in the [Types Configuration](README.md#schema-definitions). The default value is     recommended for optimal performance under load. The smallest possible value also depends     on the maximum number of joins per feature type, smaller values are rejected.",
          "type": "number"
        },
        "minConnections": {
          "title": "minConnections",
          "description": "Minimum number of connections to the database that are maintained.",
          "type": "number"
        },
        "initFailFast": {
          "title": "initFailFast",
          "description": "If disabled the provider will wait longer for the first database connection to be     established. Has no effect if `minConnections` is `0`. Should normally be disabled only     on development systems.",
          "type": "boolean",
          "deprecated": true
        },
        "initFailTimeout": {
          "title": "initFailTimeout",
          "description": "",
          "type": "string"
        },
        "idleTimeout": {
          "title": "idleTimeout",
          "description": "The maximum amount of time that a connection is allowed to sit idle in the pool. Only     applies to connections beyond the `minConnections` limit. A value of 0 means that idle     connections are never removed from the pool.",
          "type": "string"
        },
        "shared": {
          "title": "shared",
          "description": "If enabled for multiple providers with matching `host`, `database` and `user`, a     single connection pool will be shared between these providers. If any of the other     `connectionInfo` options do not match, the provider startup will fail.",
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "FeatureActionTrigger": {
      "title": "FeatureActionTrigger",
      "description": "",
      "type": "object",
      "properties": {
        "onDelete": {
          "title": "onDelete",
          "description": "",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "SqlPathDefaults": {
      "title": "SqlPathDefaults",
      "description": "",
      "type": "object",
      "properties": {
        "primaryKey": {
          "title": "primaryKey",
          "description": "The default column that is used for join analysis if no differing primary key is set in     the [sourcePath](#path-syntax).",
          "type": "string"
        },
        "defaultPrimaryKey": {
          "title": "defaultPrimaryKey",
          "description": "*Deprecated* See `primaryKey`.",
          "type": "string",
          "deprecated": true
        },
        "sortKey": {
          "title": "sortKey",
          "description": "The default column that is used to sort rows if no differing sort key is set in the     [sourcePath](#path-syntax).",
          "type": "string"
        },
        "defaultSortKey": {
          "title": "defaultSortKey",
          "description": "*Deprecated* See `sortKey`.",
          "type": "string",
          "deprecated": true
        },
        "schema": {
          "title": "schema",
          "description": "The default schema that is applied to tables without prefix in     [sourcePaths](#path-syntax).",
          "type": "string"
        },
        "junctionTablePattern": {
          "title": "junctionTablePattern",
          "description": "",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "ConnectionInfoSql": {
      "title": "ConnectionInfoSql",
      "description": "",
      "type": "object",
      "properties": {
        "connectionUri": {
          "title": "connectionUri",
          "description": "",
          "type": "string"
        },
        "connectorType": {
          "title": "connectorType",
          "description": "Always `SLICK`.",
          "type": "string"
        },
        "dialect": {
          "title": "dialect",
          "description": "`PGIS` for PostgreSQL/PostGIS, `GPKG` for GeoPackage or SQLite/SpatiaLite.",
          "type": "string"
        },
        "database": {
          "title": "database",
          "description": "The name of the database. For `GPKG` the file path, either absolute or relative to the     [data folder](../../application/30-data-folder.md).",
          "type": "string"
        },
        "host": {
          "title": "host",
          "description": "The database host. To use a non-default port, add it to the host separated by `:`, e.g.     `db:30305`. Not relevant for `GPKG`.",
          "type": "string"
        },
        "user": {
          "title": "user",
          "description": "The user name. Not relevant for `GPKG`.",
          "type": "string"
        },
        "password": {
          "title": "password",
          "description": "The base64 encoded password of the user. Not relevant for `GPKG`.",
          "type": "string"
        },
        "schemas": {
          "title": "schemas",
          "description": "The names of database schemas that should be used in addition to `public`. Not relevant     for `GPKG`.",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        },
        "pool": {
          "title": "pool",
          "description": "Connection pool settings, for details see [Pool](#connection-pool) below.",
          "type": "object",
          "$ref": "#/$defs/PoolSettings"
        },
        "driverOptions": {
          "title": "driverOptions",
          "description": "Custom options for the JDBC driver. For `PGIS`, you might pass `gssEncMode`, `ssl`,     `sslmode`, `sslcert`, `sslkey`, `sslrootcert` and `sslpassword`. For details see the     [driver     documentation](https://jdbc.postgresql.org/documentation/head/connect.html#connection-parameters).",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "triggers": {
          "title": "triggers",
          "description": "",
          "type": "object",
          "$ref": "#/$defs/FeatureActionTrigger"
        },
        "maxConnections": {
          "title": "maxConnections",
          "description": "*Deprecated* See `pool.maxConnections`.",
          "type": "number",
          "deprecated": true
        },
        "maxThreads": {
          "title": "maxThreads",
          "description": "*Deprecated* See `maxConnections`.",
          "type": "number",
          "deprecated": true
        },
        "minConnections": {
          "title": "minConnections",
          "description": "*Deprecated* See `pool.minConnections`.",
          "type": "number",
          "deprecated": true
        },
        "initFailFast": {
          "title": "initFailFast",
          "description": "*Deprecated* See `pool.initFailFast`.",
          "type": "boolean",
          "deprecated": true
        },
        "computeNumberMatched": {
          "title": "computeNumberMatched",
          "description": "*Deprecated* See [Query Generation](#query-generation) below.",
          "type": "boolean",
          "deprecated": true
        },
        "pathSyntax": {
          "title": "pathSyntax",
          "description": "*Deprecated* See [Source Path Defaults](#source-path-defaults) below.",
          "type": "object",
          "deprecated": true,
          "$ref": "#/$defs/SqlPathDefaults"
        }
      },
      "additionalProperties": false
    },
    "QueryGeneratorSettings": {
      "title": "QueryGeneratorSettings",
      "description": "",
      "type": "object",
      "properties": {
        "chunkSize": {
          "title": "chunkSize",
          "description": "",
          "type": "number"
        },
        "computeNumberMatched": {
          "title": "computeNumberMatched",
          "description": "Option to disable computation of the number of selected features for performance     reasons that are returned in `numberMatched`. As a general rule this should be disabled     for big datasets.",
          "type": "boolean"
        },
        "accentiCollation": {
          "title": "accentiCollation",
          "description": "",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "LonLat": {
      "title": "LonLat",
      "description": "",
      "type": "object",
      "properties": {
        "lon": {
          "title": "lon",
          "description": "",
          "type": "number"
        },
        "lat": {
          "title": "lat",
          "description": "",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "LevelTransformation": {
      "title": "LevelTransformation",
      "description": "",
      "type": "object",
      "properties": {
        "min": {
          "title": "min",
          "description": "",
          "type": "number"
        },
        "max": {
          "title": "max",
          "description": "",
          "type": "number"
        },
        "merge": {
          "title": "merge",
          "description": "",
          "type": "boolean"
        },
        "groupBy": {
          "title": "groupBy",
          "description": "",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        },
        "properties": {
          "title": "properties",
          "description": "",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "MinMax": {
      "title": "MinMax",
      "description": "",
      "type": "object",
      "properties": {
        "min": {
          "title": "min",
          "description": "",
          "type": "number"
        },
        "max": {
          "title": "max",
          "description": "",
          "type": "number"
        },
        "default": {
          "title": "default",
          "description": "",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "TilesetFeaturesDefaults": {
      "title": "TilesetFeaturesDefaults",
      "description": "### Tileset Defaults       Defaults that are applied to each [Tileset](#tileset).",
      "type": "object",
      "properties": {
        "center": {
          "title": "center",
          "description": "Longitude and latitude that a map with the tiles should be centered on by default.",
          "type": "object",
          "$ref": "#/$defs/LonLat"
        },
        "featureLimit": {
          "title": "featureLimit",
          "description": "Maximum number of features contained in a single tile per query.",
          "type": "number"
        },
        "minimumSizeInPixel": {
          "title": "minimumSizeInPixel",
          "description": "Features with line geometries shorter that the given value are excluded from tiles.     Features with surface geometries smaller than the square of the given value are excluded     from the tiles. The value `0.5` corresponds to half a \"pixel\" in the used coordinate     reference system.",
          "type": "number"
        },
        "ignoreInvalidGeometries": {
          "title": "ignoreInvalidGeometries",
          "description": "Ignore features with invalid geometries. Before ignoring a feature, an attempt is made     to transform the geometry to a valid geometry. The topology of geometries might be invalid     in the data source or in some cases the quantization of coordinates to integers might     render it invalid.",
          "type": "boolean"
        },
        "transformations": {
          "title": "transformations",
          "description": "Transform the selected features for a certain zoom level. Supported transformations     are: selecting a subset of feature properties (`properties`), spatial merging of features     that intersect (`merge`), with the option to restrict the operations to features with     matching attributes (`groupBy`). See the example below. For `merge`, the resulting object     will only obtain properties that are identical for all merged features.",
          "type": "object",
          "additionalProperties": {
            "allOf": [
              {
                "if": {
                  "type": "array"
                },
                "then": {
                  "items": {
                    "$ref": "#/$defs/LevelTransformation"
                  }
                }
              },
              {
                "if": {
                  "type": "object"
                },
                "then": {
                  "$ref": "#/$defs/LevelTransformation"
                }
              }
            ]
          }
        },
        "featureProvider": {
          "title": "featureProvider",
          "description": "The id of the feature provider. By default the tile provider id without `-tiles` is     used.",
          "type": "string"
        },
        "levels": {
          "title": "levels",
          "description": "Controls the zoom levels available for each active tiling scheme as well as which zoom     level to use as default.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/MinMax"
          }
        }
      },
      "additionalProperties": false
    },
    "LevelFilter": {
      "title": "LevelFilter",
      "description": "",
      "type": "object",
      "properties": {
        "min": {
          "title": "min",
          "description": "",
          "type": "number"
        },
        "max": {
          "title": "max",
          "description": "",
          "type": "number"
        },
        "filter": {
          "title": "filter",
          "description": "",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "TilesetFeatures": {
      "title": "TilesetFeatures",
      "description": "### Tileset       All options from [Tileset Defaults](#tileset-defaults) are also available and can be     overriden here.",
      "type": "object",
      "properties": {
        "id": {
          "title": "id",
          "description": "The tileset id.",
          "type": "string"
        },
        "levels": {
          "title": "levels",
          "description": "Controls the zoom levels available for each active tiling scheme as well as which zoom     level to use as default.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/MinMax"
          }
        },
        "center": {
          "title": "center",
          "description": "Longitude and latitude that a map with the tiles should be centered on by default.",
          "type": "object",
          "$ref": "#/$defs/LonLat"
        },
        "featureProvider": {
          "title": "featureProvider",
          "description": "The id of the feature provider. By default the tile provider id without `-tiles` is     used.",
          "type": "string"
        },
        "featureLimit": {
          "title": "featureLimit",
          "description": "Maximum number of features contained in a single tile per query.",
          "type": "number"
        },
        "minimumSizeInPixel": {
          "title": "minimumSizeInPixel",
          "description": "Features with line geometries shorter that the given value are excluded from tiles.     Features with surface geometries smaller than the square of the given value are excluded     from the tiles. The value `0.5` corresponds to half a \"pixel\" in the used coordinate     reference system.",
          "type": "number"
        },
        "ignoreInvalidGeometries": {
          "title": "ignoreInvalidGeometries",
          "description": "Ignore features with invalid geometries. Before ignoring a feature, an attempt is made     to transform the geometry to a valid geometry. The topology of geometries might be invalid     in the data source or in some cases the quantization of coordinates to integers might     render it invalid.",
          "type": "boolean"
        },
        "transformations": {
          "title": "transformations",
          "description": "Transform the selected features for a certain zoom level. Supported transformations     are: selecting a subset of feature properties (`properties`), spatial merging of features     that intersect (`merge`), with the option to restrict the operations to features with     matching attributes (`groupBy`). See the example below. For `merge`, the resulting object     will only obtain properties that are identical for all merged features.",
          "type": "object",
          "additionalProperties": {
            "allOf": [
              {
                "if": {
                  "type": "array"
                },
                "then": {
                  "items": {
                    "$ref": "#/$defs/LevelTransformation"
                  }
                }
              },
              {
                "if": {
                  "type": "object"
                },
                "then": {
                  "$ref": "#/$defs/LevelTransformation"
                }
              }
            ]
          }
        },
        "featureType": {
          "title": "featureType",
          "description": "The name of the feature type. By default the tileset id is used.",
          "type": "string"
        },
        "combine": {
          "title": "combine",
          "description": "Instead of being generated using a `featureType`, a tileset may be composed of multiple     other tilesets. Takes a list of tileset ids. A list with a single entry `*` combines all     tilesets.",
          "allOf": [
            {
              "if": {
                "type": "array"
              },
              "then": {
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "if": {
                "type": "object"
              },
              "then": {
                "type": "string"
              }
            }
          ]
        },
        "filters": {
          "title": "filters",
          "description": "Filters to select a subset of feature for certain zoom levels using a CQL filter     expression, see example below.",
          "type": "object",
          "additionalProperties": {
            "allOf": [
              {
                "if": {
                  "type": "array"
                },
                "then": {
                  "items": {
                    "$ref": "#/$defs/LevelFilter"
                  }
                }
              },
              {
                "if": {
                  "type": "object"
                },
                "then": {
                  "$ref": "#/$defs/LevelFilter"
                }
              }
            ]
          }
        }
      },
      "additionalProperties": false
    },
    "Cache": {
      "title": "Cache",
      "description": "### Cache       There are two different cache types:        - `IMMUTABLE` An immutable cache can only be created through seeding. It will only be made available once it is complete. If some or all tiles are re-seeded, then again the new version will only be made available once it is complete. In the meantime the old version is still provided to consumers.   Therefore an immutable cache is always consistent and, once the initial seeding has completed, it guarantees uninterrupted operation. - `DYNAMIC` A dynamic cache can be computed through seeding, but it will also cache matching tiles that are requested by a consumer. Tiles will be made available as soon as they are computed. If some or all tiles are re-seeded, they are deleted first.   Therefore a dynamic cache might be inconsistent and may cause client errors during (re-)seeding.            In general the usage of immutable caches is recommended. For higher zoom levels a     complementary non-seeded dynamic cache might make sense to reduce seeding time.              There are two different storage types:        - `PLAIN` Every tile is stored in a single file. This is recommended for remote storage (coming soon). - `MBTILES` Tiles are stored in a [MBTiles](https://github.com/mapbox/mbtiles-spec) file per tiling scheme. This is recommended for local storage.",
      "type": "object",
      "properties": {
        "type": {
          "title": "type",
          "description": "Either `IMMUTABLE` or `DYNAMIC`.",
          "type": "string"
        },
        "storage": {
          "title": "storage",
          "description": "Either `PLAIN` or `MBTILES`.",
          "type": "string"
        },
        "seeded": {
          "title": "seeded",
          "description": "Should this cache be included by the [Seeding](#seeding)?",
          "type": "boolean"
        },
        "levels": {
          "title": "levels",
          "description": "Tiling schemes and zoom levels that should be stored in the cache. Applies to all     tilesets that are not specified in `tilesetLevels`.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/MinMax"
          }
        },
        "tilesetLevels": {
          "title": "tilesetLevels",
          "description": "Tiling schemes and zoom levels for single tilesets that should be stored in the cache.",
          "type": "object",
          "additionalProperties": {
            "additionalProperties": {
              "$ref": "#/$defs/MinMax"
            }
          }
        }
      },
      "additionalProperties": false
    },
    "SeedingOptions": {
      "title": "SeedingOptions",
      "description": "### Seeding       Controls how and when [caches](#cache) are computed.",
      "type": "object",
      "properties": {
        "runOnStartup": {
          "title": "runOnStartup",
          "description": "If disabled the seeding will not be run when the API starts.",
          "type": "boolean"
        },
        "runPeriodic": {
          "title": "runPeriodic",
          "description": "A crontab pattern to run the seeding periodically. There will only ever be one seeding     in progress, so if the next run is scheduled before the last one finished, it will be     skipped.",
          "type": "string"
        },
        "purge": {
          "title": "purge",
          "description": "If enabled the tile cache will be purged before the seeding starts.",
          "type": "boolean"
        },
        "maxThreads": {
          "title": "maxThreads",
          "description": "The maximum number of threads the seeding is allowed to use. The actual number of     threads used depends on the number of available background task threads when the seeding is     about to start. If you want to allow more than thread, first check if sufficient background     task threads are configured. Take into account that the seeding for multiple APIs will     compete for the available background task threads.",
          "type": "number"
        }
      },
      "additionalProperties": false
    },
    "TilesetMbTilesDefaults": {
      "title": "TilesetMbTilesDefaults",
      "description": "",
      "type": "object",
      "properties": {
        "center": {
          "title": "center",
          "description": "Longitude and latitude that a map with the tiles should be centered on by default.",
          "type": "object",
          "$ref": "#/$defs/LonLat"
        },
        "levels": {
          "title": "levels",
          "description": "Controls the zoom levels available for each active tiling scheme as well as which zoom     level to use as default.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/MinMax"
          }
        }
      },
      "additionalProperties": false
    },
    "TilesetMbTiles": {
      "title": "TilesetMbTiles",
      "description": "",
      "type": "object",
      "properties": {
        "id": {
          "title": "id",
          "description": "The tileset id.",
          "type": "string"
        },
        "levels": {
          "title": "levels",
          "description": "Controls the zoom levels available for each active tiling scheme as well as which zoom     level to use as default.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/MinMax"
          }
        },
        "center": {
          "title": "center",
          "description": "Longitude and latitude that a map with the tiles should be centered on by default.",
          "type": "object",
          "$ref": "#/$defs/LonLat"
        },
        "source": {
          "title": "source",
          "description": "Filename of the MBTiles file in the `api-resources/tiles` directory.",
          "type": "string"
        }
      },
      "additionalProperties": false
    },
    "TilesetHttpDefaults": {
      "title": "TilesetHttpDefaults",
      "description": "### Tileset Defaults       Defaults that are applied to each [Tileset](#tileset).",
      "type": "object",
      "properties": {
        "center": {
          "title": "center",
          "description": "Longitude and latitude that a map with the tiles should be centered on by default.",
          "type": "object",
          "$ref": "#/$defs/LonLat"
        },
        "encodings": {
          "title": "encodings",
          "description": "Supported tile encodings. Keys have to be one of `MVT`, `PNG`, `WebP` and `JPEG`,     values are provided as `{{fileExtension}}` in `urlTemplate`.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "levels": {
          "title": "levels",
          "description": "Controls the zoom levels available for each active tiling scheme as well as which zoom     level to use as default.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/MinMax"
          }
        }
      },
      "additionalProperties": false
    },
    "TilesetHttp": {
      "title": "TilesetHttp",
      "description": "### Tileset       All options from [Tileset Defaults](#tileset-defaults) are also available and can be     overriden here.",
      "type": "object",
      "properties": {
        "id": {
          "title": "id",
          "description": "The tileset id.",
          "type": "string"
        },
        "levels": {
          "title": "levels",
          "description": "Controls the zoom levels available for each active tiling scheme as well as which zoom     level to use as default.",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/$defs/MinMax"
          }
        },
        "center": {
          "title": "center",
          "description": "Longitude and latitude that a map with the tiles should be centered on by default.",
          "type": "object",
          "$ref": "#/$defs/LonLat"
        },
        "encodings": {
          "title": "encodings",
          "description": "Supported tile encodings. Keys have to be one of `MVT`, `PNG`, `WebP` and `JPEG`,     values are provided as `{{fileExtension}}` in `urlTemplate`.",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "urlTemplate": {
          "title": "urlTemplate",
          "description": "URL template for accessing tiles. Parameters to use are `{{tileMatrix}}`,     `{{tileRow}}`, `{{tileCol}}` and `{{fileExtension}}`. Single curly braces are also allowed.",
          "type": "string"
        }
      },
      "additionalProperties": false
    }
  }
}